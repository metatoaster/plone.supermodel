==================================================
plone.supermodel: content schemata loaded from XML
==================================================

This package allows content schemata to be read and written as XML. It has a 
standard importer and serialiser for interfaces that contain zope.schema
fields. The format is general enough to be able to handle future fields
easily, so long as they are properly specified through interfaces.

Parsing and serializing simple schemata
---------------------------------------

Before we can begin, we must register the field handlers that know how to
import and export fields from/to XML. These are registered as named utilities,
and can be loaded from the configure.zcml file of plone.supermodel.

    >>> configuration = """\
    ... <configure
    ...      xmlns="http://namespaces.zope.org/zope"
    ...      i18n_domain="plone.behavior.tests">
    ...      
    ...     <include package="zope.component" file="meta.zcml" />
    ...     
    ...     <include package="plone.supermodel" />
    ...     
    ... </configure>
    ... """

    >>> from StringIO import StringIO
    >>> from zope.configuration import xmlconfig
    >>> xmlconfig.xmlconfig(StringIO(configuration))

Next, let's define a sample model with a single, unnamed schema.

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model>
    ...     <schema>
    ...         <field type="zope.schema.TextLine" name="title">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="description">
    ...             <title>Description</title>
    ...             <description>A short summary</description>
    ...             <required>False</required>
    ...             <min_length>10</min_length>
    ...         </field>
    ...     </schema>
    ... </model>
    ... """

We can parse this model using the long_string() function:

    >>> from plone.supermodel import load_string
    >>> model = load_string(schema)

This will load one schema, with the default name u"":

    >>> model['schemata'].keys()
    [u'']
    
We can inspect this schema and see that it contains zope.schema fields with
attributes corresponding to the values set in XML.

    >>> schema = model['schemata'][u""]
    >>> from zope.schema import getFieldsInOrder
    >>> [field for field, _ in getFieldsInOrder(schema)]
    ['title', 'description']
    
    >>> schema['title'].title
    u'Title'
    >>> schema['title'].required
    True
    
    >>> schema['description'].title
    u'Description'
    >>> schema['description'].description
    u'A short summary'
    >>> schema['description'].required
    False
    >>> schema['description'].min_length
    10

Similarly, we can serialize a model to an XML representation:

    >>> from plone.supermodel import serialize_model
    >>> print serialize_model(model) # doctest: +NORMALIZE_WHITESPACE
    <model>
      <schema>
        <field name="title" type="zope.schema.TextLine">
          <title>Title</title>
        </field><field name="description" type="zope.schema.Text">
          <min_length>10</min_length>
          <description>A short summary</description>
          <title>Description</title>
          <required>False</required>
        </field>
      </schema>
    </model>

Building interfaces from schemata
---------------------------------

Above, we saw how to parse a schema from a file directly. Next, let's see how 
this can be used more practically to define a custom interface. Here, we will
use two schemata in one file.

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model>
    ...     <schema>
    ...         <field type="zope.schema.TextLine" name="title">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="body">
    ...             <title>Body text</title>
    ...             <required>True</required>
    ...             <max_length>10000</max_length>
    ...         </field>
    ...     </schema>
    ...     
    ...     <schema name="metadata">
    ...         <field type="zope.schema.Datetime" name="created">
    ...             <title>Created date</title>
    ...             <required>False</required>
    ...         </field>
    ...         <field type="zope.schema.TextLine" name="creator">
    ...             <title>Creator</title>
    ...             <description>Name of the creator</description>
    ...             <required>True</required>
    ...         </field>
    ...     </schema>
    ...     
    ... </model>
    ... """

Ordinarily, this would be in a file, probably in the same directory as the
module containing the interface being defined. Here, we need to create a 
temporary directory.

    >>> import tempfile, os.path, shutil
    >>> tmpdir = tempfile.mkdtemp()
    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
    >>> schema_file = open(schema_filename, "w")
    >>> schema_file.write(schema)
    >>> schema_file.close()

We can define interfaces from this with a convenient syntax:

    >>> from plone.supermodel import xml_schema
    >>> class ITestContent( xml_schema(schema_filename) ):
    ...     """Test content type schema, built from XML
    ...     """

Note: If the schema filename is not an absolute path, it will be found 
relative to the module where the interface is defined (or, more accurately,
the module that's calling the xml_schema() function).

The resulting interface now has the fields of the default (unnamed) schema:

    >>> from zope.schema import getFieldsInOrder
    >>> [field for field, _ in getFieldsInOrder(ITestContent)]
    ['title', 'body']

We can also use a different, named schema:

    >>> class ITestMetadata( xml_schema(schema_filename, schema="metadata") ):
    ...     """Test metadata schema, built from XML
    ...     """

    >>> from zope.schema import getFieldsInOrder
    >>> [field for field, _ in getFieldsInOrder(ITestMetadata)]
    ['created', 'creator']
    
Of course, a schema can also be written to XML. Either, you can build a model
dict as per the serialize_model() method seen above, or you can write a model
of just a single schema using serialize_schema():

    >>> from plone.supermodel import serialize_schema
    >>> print serialize_schema(ITestContent) # doctest: +NORMALIZE_WHITESPACE
    <model>
      <schema>
        <field name="title" type="zope.schema.TextLine">
          <title>Title</title>
        </field><field name="body" type="zope.schema.Text">
          <title>Body text</title>
          <max_length>10000</max_length>
        </field>
      </schema>
    </model>
    
    >>> print serialize_schema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE
    <model>
      <schema name="metadata">
        <field name="created" type="zope.schema.Datetime">
          <required>False</required>
          <title>Created date</title>
        </field><field name="creator" type="zope.schema.TextLine">
          <description>Name of the creator</description>
          <title>Creator</title>
        </field>
      </schema>
    </model>
    
Finally, let's clean up the temporary directory.

    >>> shutil.rmtree(tmpdir)

Creating custom metadata handlers
---------------------------------

The plone.supermodel format is extensible with custom utilities that can
write to a "metadata" dictionary. Such utilities may for example read
information captured in attributes in particular namespaces.

Let's imagine we wanted to make it possible to override form layout on a
per-schema level, and override widgets on a per-field level. For this, we
may expect to be able to parse a format like this:

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model xmlns:ui="http://namespaces.acme.com/ui">
    ...     <schema ui:layout="horizontal">
    ...         <field type="zope.schema.TextLine" name="title"
    ...             ui:widget="largetype">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="description">
    ...             <title>Description</title>
    ...             <description>A short summary</description>
    ...             <required>False</required>
    ...             <min_length>10</min_length>
    ...         </field>
    ...     </schema>
    ... </model>
    ... """

We can register schema and field metadata handlers as named utilities.
Metadata handlers should be able to reciprocally read and write metadata.

    >>> from zope.interface import implements
    >>> from zope.component import provideUtility

    >>> from plone.supermodel.interfaces import ISchemaMetadataHandler
    >>> class FormLayoutMetadata(object):
    ...     implements(ISchemaMetadataHandler)
    ...     
    ...     namespace = "http://namespaces.acme.com/ui"
    ...     prefix = "ui"
    ...     
    ...     def read(self, schema_node, schema, schema_metadata):
    ...         layout = schema_node.get('{%s}layout' % self.namespace)
    ...         if layout:
    ...             schema_metadata['layout'] = layout
    ...             
    ...     def write(self, schema_node, schema, schema_metadata):
    ...         layout = schema_metadata.get('layout', None)
    ...         if layout:
    ...             schema_node.set('{%s}layout' % self.namespace, layout)
    ...             
    >>> provideUtility(component=FormLayoutMetadata(), name='acme.ui.schema')

    >>> from plone.supermodel.interfaces import IFieldMetadataHandler
    >>> class FieldWidgetMetadata(object):
    ...     implements(IFieldMetadataHandler)
    ...     
    ...     namespace = "http://namespaces.acme.com/ui"
    ...     prefix = "ui"
    ...         
    ...     def read(self, field_node, field, schema_metadata):
    ...         widget = field_node.get('{%s}widget' % self.namespace)
    ...         if widget:
    ...             name = field.__name__
    ...             schema_metadata.setdefault(name, {})['widget'] = widget
    ...
    ...     def write(self, field_node, field, schema_metadata):
    ...         name = field.__name__
    ...         widget = schema_metadata.get(name, {}).get('widget', {})
    ...         if widget:
    ...             field_node.set('{%s}widget' % self.namespace, widget)
    >>> provideUtility(component=FieldWidgetMetadata(), name='acme.ui.fields')

When this model is loaded, the 'metadata' part will contain keys 
'acme.ui.schema' and 'acme.ui.fields', where the metadata above will be stored.

    >>> model = load_string(schema)

The keys in the 'metadata' dict are schema names:

    >>> model['metadata'].keys()
    [u'']

Under each schema, we will find one key for each named utility. Since we
registered both the schema and the field utilities under the same name, they
share a key.

    >>> sorted(model['metadata'][u""].keys())
    [u'acme.ui.fields', u'acme.ui.schema']

    >>> model['metadata'][u""][u'acme.ui.schema']
    {'layout': 'horizontal'}

    >>> model['metadata'][u""][u'acme.ui.fields']
    {'title': {'widget': 'largetype'}}

Of course, we can also serialize the schema back to XML. Here, the 'prefix'
set in the utility (if any) will be used by default.

    >>> print serialize_model(model) # doctest: +NORMALIZE_WHITESPACE
    <model>
      <schema ui:layout="horizontal" xmlns:ui="http://namespaces.acme.com/ui">
        <field name="title" type="zope.schema.TextLine" ui:widget="largetype">
          <title>Title</title>
        </field><field name="description" type="zope.schema.Text">
          <min_length>10</min_length>
          <description>A short summary</description>
          <title>Description</title>
          <required>False</required>
        </field>
      </schema>
    </model>