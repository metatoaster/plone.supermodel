==================================================
plone.supermodel: content schemata loaded from XML
==================================================

This package allows content schemata to be read and written as XML. It has a 
standard importer and serialiser for interfaces that contain zope.schema
fields. The format is general enough to be able to handle future fields
easily, so long as they are properly specified through interfaces.

Parsing and serializing simple schemata
---------------------------------------

Before we can begin, we must register the field handlers that know how to
import and export fields from/to XML. These are registered as named utilities,
and can be loaded from the configure.zcml file of plone.supermodel.

    >>> configuration = """\
    ... <configure
    ...      xmlns="http://namespaces.zope.org/zope"
    ...      i18n_domain="plone.behavior.tests">
    ...      
    ...     <include package="zope.component" file="meta.zcml" />
    ...     
    ...     <include package="plone.supermodel" />
    ...     
    ... </configure>
    ... """

    >>> from StringIO import StringIO
    >>> from zope.configuration import xmlconfig
    >>> xmlconfig.xmlconfig(StringIO(configuration))

Next, let's define a sample model with a single, unnamed schema.

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
    ...     <schema>
    ...         <field type="zope.schema.TextLine" name="title">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="description">
    ...             <title>Description</title>
    ...             <description>A short summary</description>
    ...             <required>False</required>
    ...             <min_length>10</min_length>
    ...         </field>
    ...     </schema>
    ... </model>
    ... """

We can parse this model using the long_string() function:

    >>> from plone.supermodel import load_string
    >>> model = load_string(schema)

This will load one schema, with the default name u"":

    >>> model.schemata.keys()
    [u'']
    
We can inspect this schema and see that it contains zope.schema fields with
attributes corresponding to the values set in XML.

    >>> schema = model.schema # shortcut to model.schemata[u""]
    >>> from zope.schema import getFieldsInOrder
    >>> [field for field, _ in getFieldsInOrder(schema)]
    ['title', 'description']
    
    >>> schema['title'].title
    u'Title'
    >>> schema['title'].required
    True
    
    >>> schema['description'].title
    u'Description'
    >>> schema['description'].description
    u'A short summary'
    >>> schema['description'].required
    False
    >>> schema['description'].min_length
    10

Similarly, we can serialize a model to an XML representation:

    >>> from plone.supermodel import serialize_model
    >>> print serialize_model(model) # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema>
        <field name="title" type="zope.schema.TextLine">
          <title>Title</title>
        </field><field name="description" type="zope.schema.Text">
          <min_length>10</min_length>
          <description>A short summary</description>
          <title>Description</title>
          <required>False</required>
        </field>
      </schema>
    </model>

Building interfaces from schemata
---------------------------------

Above, we saw how to parse a schema from a file directly. Next, let's see how 
this can be used more practically to define a custom interface. Here, we will
use two schemata in one file.

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
    ...     <schema>
    ...         <field type="zope.schema.TextLine" name="title">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="body">
    ...             <title>Body text</title>
    ...             <required>True</required>
    ...             <max_length>10000</max_length>
    ...         </field>
    ...     </schema>
    ...     
    ...     <schema name="metadata">
    ...         <field type="zope.schema.Datetime" name="created">
    ...             <title>Created date</title>
    ...             <required>False</required>
    ...         </field>
    ...         <field type="zope.schema.TextLine" name="creator">
    ...             <title>Creator</title>
    ...             <description>Name of the creator</description>
    ...             <required>True</required>
    ...         </field>
    ...     </schema>
    ...     
    ... </model>
    ... """

Ordinarily, this would be in a file in the same directory as the module
containing the interface being defined. Here, we need to create a temporary
directory.

    >>> import tempfile, os.path, shutil
    >>> tmpdir = tempfile.mkdtemp()
    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
    >>> schema_file = open(schema_filename, "w")
    >>> schema_file.write(schema)
    >>> schema_file.close()

We can define interfaces from this with a convenient syntax:

    >>> from plone.supermodel.directives import Schema, model
    >>> class ITestContent(Schema):
    ...     model(schema_filename)
    
Note: If the schema filename is not an absolute path, it will be found 
relative to the module where the interface is defined.

This class can be "grokked" to produce a proper schema interface. To do so,
you must first ensure that the meta.zcml file from plone.supermodel is loaded.
We simulate this in the test:

    >>> from grokcore.component.testing import grok, grok_component
    >>> grok('plone.supermodel.directives')

Then, add the following in the configure.zcml file for the package where the
interface is defined:

    <configure xmlns="http://namespaces.zope.org/zope"
               xmlns:grok="http://namespaces.zope.org/grok">

        <grok:grok package="." />

    </configure>

Again, for the purposes of testing, we will simulate this with a helper 
function from grokcore.component:

    >>> grok_component('ITestContent', ITestContent)
    True

After grokking, the interface should have the fields of the default (unnamed)
schema:

    >>> from zope.schema import getFieldsInOrder
    >>> [field for field, _ in getFieldsInOrder(ITestContent)]
    ['title', 'body']

It also contains the filename that the schema was loaded from and the schema 
name as a tagged values in the base interface.

    >>> from plone.supermodel.model import FILENAME_KEY, SCHEMA_NAME_KEY
    >>> ITestContent.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
    '.../schema.xml'
    >>> ITestContent.getTaggedValue(SCHEMA_NAME_KEY)
    u''

We can also use a different, named schema:

    >>> class ITestMetadata(Schema):
    ...     """Test metadata schema, built from XML
    ...     """
    ...     model(schema_filename, schema=u"metadata")

    >>> grok_component('ITestMetadata', ITestMetadata)
    True

    >>> from zope.schema import getFieldsInOrder
    >>> [field for field, _ in getFieldsInOrder(ITestMetadata)]
    ['created', 'creator']

This interface also has tagged values for the filename and schema name.

    >>> ITestMetadata.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
    '.../schema.xml'
    >>> ITestMetadata.getTaggedValue(SCHEMA_NAME_KEY)
    u'metadata'
    

Of course, a schema can also be written to XML. Either, you can build a model
dict as per the serialize_model() method seen above, or you can write a model
of just a single schema using serialize_schema():

    >>> from plone.supermodel import serialize_schema
    >>> print serialize_schema(ITestContent) # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema>
        <field name="title" type="zope.schema.TextLine">
          <title>Title</title>
        </field><field name="body" type="zope.schema.Text">
          <title>Body text</title>
          <max_length>10000</max_length>
        </field>
      </schema>
    </model>
    
    >>> print serialize_schema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema name="metadata">
        <field name="created" type="zope.schema.Datetime">
          <required>False</required>
          <title>Created date</title>
        </field><field name="creator" type="zope.schema.TextLine">
          <description>Name of the creator</description>
          <title>Creator</title>
        </field>
      </schema>
    </model>
    
Finally, let's clean up the temporary directory.

    >>> shutil.rmtree(tmpdir)

Creating custom metadata handlers
---------------------------------

The plone.supermodel format is extensible with custom utilities that can
write to a "metadata" dictionary. Such utilities may for example read
information captured in attributes in particular namespaces.

Let's imagine we wanted to make it possible to override form layout on a
per-schema level, and override widgets on a per-field level. For this, we
may expect to be able to parse a format like this:

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
    ...        xmlns:ui="http://namespaces.acme.com/ui">
    ...     <schema ui:layout="horizontal">
    ...         <field type="zope.schema.TextLine" name="title"
    ...             ui:widget="largetype">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="description">
    ...             <title>Description</title>
    ...             <description>A short summary</description>
    ...             <required>False</required>
    ...             <min_length>10</min_length>
    ...         </field>
    ...     </schema>
    ... </model>
    ... """

We can register schema and field metadata handlers as named utilities.
Metadata handlers should be able to reciprocally read and write metadata.

    >>> from zope.interface import implements
    >>> from zope.component import provideUtility

    >>> from plone.supermodel.interfaces import ISchemaMetadataHandler
    >>> from plone.supermodel.utils import ns

    >>> class FormLayoutMetadata(object):
    ...     implements(ISchemaMetadataHandler)
    ...     
    ...     namespace = "http://namespaces.acme.com/ui"
    ...     prefix = "ui"
    ...     
    ...     def read(self, schema_node, schema, schema_metadata):
    ...         layout = schema_node.get(ns('layout', self.namespace))
    ...         if layout:
    ...             schema_metadata['layout'] = layout
    ...             
    ...     def write(self, schema_node, schema, schema_metadata):
    ...         layout = schema_metadata.get('layout', None)
    ...         if layout:
    ...             schema_node.set(ns('layout', self.namespace), layout)

    >>> provideUtility(component=FormLayoutMetadata(), name='acme.ui.schema')

    >>> from plone.supermodel.interfaces import IFieldMetadataHandler
    >>> class FieldWidgetMetadata(object):
    ...     implements(IFieldMetadataHandler)
    ...     
    ...     namespace = "http://namespaces.acme.com/ui"
    ...     prefix = "ui"
    ...         
    ...     def read(self, field_node, field, schema_metadata):
    ...         widget = field_node.get(ns('widget', self.namespace))
    ...         if widget:
    ...             name = field.__name__
    ...             schema_metadata.setdefault(name, {})['widget'] = widget
    ...
    ...     def write(self, field_node, field, schema_metadata):
    ...         name = field.__name__
    ...         widget = schema_metadata.get(name, {}).get('widget', {})
    ...         if widget:
    ...             field_node.set(ns('widget', self.namespace), widget)

    >>> provideUtility(component=FieldWidgetMetadata(), name='acme.ui.fields')

When this model is loaded, the 'metadata' of each schema that was parsed
will contain keys 'acme.ui.schema' and 'acme.ui.fields', where the metadata above will be stored. The default schema's metadata is available under
'model.metadata'.

    >>> model = load_string(schema)

    >>> sorted(model.metadata.keys())
    [u'acme.ui.fields', u'acme.ui.schema']

    >>> model.metadata[u'acme.ui.schema']
    {'layout': 'horizontal'}

    >>> model.metadata[u'acme.ui.fields']
    {'title': {'widget': 'largetype'}}

Of course, we can also serialize the schema back to XML. Here, the 'prefix'
set in the utility (if any) will be used by default.

    >>> print serialize_model(model) # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema ui:layout="horizontal" xmlns:ui="http://namespaces.acme.com/ui">
        <field name="title" type="zope.schema.TextLine" ui:widget="largetype">
          <title>Title</title>
        </field><field name="description" type="zope.schema.Text">
          <min_length>10</min_length>
          <description>A short summary</description>
          <title>Description</title>
          <required>False</required>
        </field>
      </schema>
    </model>