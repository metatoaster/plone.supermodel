==================================================
plone.supermodel: content schemata loaded from XML
==================================================

This package allows content schemata to be read and written as XML. It has a 
standard importer and serialiser for interfaces that contain zope.schema
fields. The format is general enough to be able to handle future fields
easily, so long as they are properly specified through interfaces.

Parsing and serializing simple schemata
---------------------------------------

Before we can begin, we must register the field handlers that know how to
import and export fields from/to XML. These are registered as named utilities,
and can be loaded from the configure.zcml file of plone.supermodel.

    >>> configuration = """\
    ... <configure
    ...      xmlns="http://namespaces.zope.org/zope"
    ...      i18n_domain="plone.behavior.tests">
    ...      
    ...     <include package="zope.component" file="meta.zcml" />
    ...     
    ...     <include package="plone.supermodel" />
    ...     
    ... </configure>
    ... """

    >>> from StringIO import StringIO
    >>> from zope.configuration import xmlconfig
    >>> xmlconfig.xmlconfig(StringIO(configuration))

Next, let's define a sample model with a single, unnamed schema.

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
    ...     <schema>
    ...         <field type="zope.schema.TextLine" name="title">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="description">
    ...             <title>Description</title>
    ...             <description>A short summary</description>
    ...             <required>False</required>
    ...             <min_length>10</min_length>
    ...         </field>
    ...     </schema>
    ... </model>
    ... """

We can parse this model using the long_string() function:

    >>> from plone.supermodel import load_string
    >>> model = load_string(schema)

This will load one schema, with the default name u"":

    >>> model.schemata.keys()
    [u'']
    
We can inspect this schema and see that it contains zope.schema fields with
attributes corresponding to the values set in XML.

    >>> schema = model.schema # shortcut to model.schemata[u""]

    >>> from zope.schema import getFieldNamesInOrder
    >>> getFieldNamesInOrder(schema)
    ['title', 'description']
    
    >>> schema['title'].title
    u'Title'
    >>> schema['title'].required
    True
    
    >>> schema['description'].title
    u'Description'
    >>> schema['description'].description
    u'A short summary'
    >>> schema['description'].required
    False
    >>> schema['description'].min_length
    10

Similarly, we can serialize a model to an XML representation:

    >>> from plone.supermodel import serialize_model
    >>> print serialize_model(model) # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema>
        <field name="title" type="zope.schema.TextLine">
          <title>Title</title>
        </field><field name="description" type="zope.schema.Text">
          <min_length>10</min_length>
          <description>A short summary</description>
          <title>Description</title>
          <required>False</required>
        </field>
      </schema>
    </model>

Building interfaces from schemata
---------------------------------

Above, we saw how to parse a schema from a file directly. Next, let's see how 
this can be used more practically to define a custom interface. Here, we will
use two schemata in one file.

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
    ...     <schema>
    ...         <field type="zope.schema.TextLine" name="title">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="body">
    ...             <title>Body text</title>
    ...             <required>True</required>
    ...             <max_length>10000</max_length>
    ...         </field>
    ...     </schema>
    ...     
    ...     <schema name="metadata">
    ...         <field type="zope.schema.Datetime" name="created">
    ...             <title>Created date</title>
    ...             <required>False</required>
    ...         </field>
    ...         <field type="zope.schema.TextLine" name="creator">
    ...             <title>Creator</title>
    ...             <description>Name of the creator</description>
    ...             <required>True</required>
    ...         </field>
    ...     </schema>
    ...     
    ... </model>
    ... """

Ordinarily, this would be in a file in the same directory as the module
containing the interface being defined. Here, we need to create a temporary
directory.

    >>> import tempfile, os.path, shutil
    >>> tmpdir = tempfile.mkdtemp()
    >>> schema_filename = os.path.join(tmpdir, "schema.xml")
    >>> schema_file = open(schema_filename, "w")
    >>> schema_file.write(schema)
    >>> schema_file.close()

We can define interfaces from this with a convenient syntax:

    >>> from plone.supermodel.directives import Schema, model
    >>> class ITestContent(Schema):
    ...     model(schema_filename)
    
Note: If the schema filename is not an absolute path, it will be found 
relative to the module where the interface is defined.

This class can be "grokked" to produce a proper schema interface. To do so,
you must first ensure that the meta.zcml file from plone.supermodel is loaded.
We simulate this in the test:

    >>> from grokcore.component.testing import grok, grok_component
    >>> grok('plone.supermodel.directives')

Then, add the following in the configure.zcml file for the package where the
interface is defined:

    <configure xmlns="http://namespaces.zope.org/zope"
               xmlns:grok="http://namespaces.zope.org/grok">

        <grok:grok package="." />

    </configure>

Again, for the purposes of testing, we will simulate this with a helper 
function from grokcore.component:

    >>> grok_component('ITestContent', ITestContent)
    True

After grokking, the interface should have the fields of the default (unnamed)
schema:

    >>> getFieldNamesInOrder(ITestContent)
    ['title', 'body']

It also contains the filename that the schema was loaded from and the schema 
name as a tagged values in the base interface.

    >>> from plone.supermodel.model import FILENAME_KEY, SCHEMA_NAME_KEY
    >>> ITestContent.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
    '.../schema.xml'
    >>> ITestContent.getTaggedValue(SCHEMA_NAME_KEY)
    u''

We can also use a different, named schema:

    >>> class ITestMetadata(Schema):
    ...     """Test metadata schema, built from XML
    ...     """
    ...     model(schema_filename, schema=u"metadata")

    >>> grok_component('ITestMetadata', ITestMetadata)
    True

    >>> getFieldNamesInOrder(ITestMetadata)
    ['created', 'creator']

This interface also has tagged values for the filename and schema name.

    >>> ITestMetadata.getTaggedValue(FILENAME_KEY) # doctest: +ELLIPSIS
    '.../schema.xml'
    >>> ITestMetadata.getTaggedValue(SCHEMA_NAME_KEY)
    u'metadata'
    

Of course, a schema can also be written to XML. Either, you can build a model
dict as per the serialize_model() method seen above, or you can write a model
of just a single schema using serialize_schema():

    >>> from plone.supermodel import serialize_schema
    >>> print serialize_schema(ITestContent) # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema>
        <field name="title" type="zope.schema.TextLine">
          <title>Title</title>
        </field><field name="body" type="zope.schema.Text">
          <title>Body text</title>
          <max_length>10000</max_length>
        </field>
      </schema>
    </model>
    
    >>> print serialize_schema(ITestMetadata, name=u"metadata") # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema name="metadata">
        <field name="created" type="zope.schema.Datetime">
          <required>False</required>
          <title>Created date</title>
        </field><field name="creator" type="zope.schema.TextLine">
          <description>Name of the creator</description>
          <title>Creator</title>
        </field>
      </schema>
    </model>
    
Finally, let's clean up the temporary directory.

    >>> shutil.rmtree(tmpdir)

Fieldset support
----------------

It is often useful to be able to group form fields in the same schema into
fieldsets, for example for form rendering. While plone.supermodel doesn't have
anything to do with such rendering, it does support some markup to make it
possible to define fieldsets. These are stored in a tagged value on the
generated interface, which can then be used by other code.

Fieldsets can be defined from and serialised to XML, using the <fieldset />
tag to wrap a sequence of fields.

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model xmlns="http://namespaces.plone.org/supermodel/schema">
    ...     <schema>
    ...     
    ...         <field type="zope.schema.TextLine" name="title">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="body">
    ...             <title>Body text</title>
    ...             <required>True</required>
    ...             <max_length>10000</max_length>
    ...         </field>
    ...         
    ...         <fieldset name="dates" label="Dates" description="Standard dates">
    ...             <field type="zope.schema.Date" name="publication_date">
    ...                 <title>Publication date</title>
    ...             </field>
    ...         </fieldset>
    ...         
    ...         <field type="zope.schema.TextLine" name="author">
    ...             <title>Author</title>
    ...         </field>
    ...         
    ...         <fieldset name="dates" label="Ignored" description="Ignored">
    ...             <field type="zope.schema.Date" name="expiry_date">
    ...                 <title>Expiry date</title>
    ...             </field>
    ...             <field type="zope.schema.Date" name="notification_date">
    ...                 <title>Notification date</title>
    ...             </field>
    ...         </fieldset>
    ...     </schema>
    ...     
    ...     <schema name="metadata">
    ...     
    ...         <fieldset name="standard" label="Standard" />
    ...         <fieldset name="dates" label="Metadata dates" />
    ...         <fieldset name="author" label="Author info" />
    ...         
    ...         <fieldset name="dates">
    ...             <field type="zope.schema.Datetime" name="created">
    ...                 <title>Created date</title>
    ...                 <required>False</required>
    ...             </field>
    ...         </fieldset>
    ...         
    ...         <fieldset name="standard">
    ...             <field type="zope.schema.TextLine" name="creator">
    ...                 <title>Creator</title>
    ...                 <description>Name of the creator</description>
    ...                 <required>True</required>
    ...             </field>
    ...         </fieldset>
    ...     </schema>
    ...     
    ... </model>
    ... """

Fields outside any <fieldset /> tag are not placed in any fieldset. An
empty <fieldset /> will be recorded as one having no fields. This is sometimes
useful to control the order of fieldsets, if those are to be filled later.

If there are two <fieldset /> blocks with the same name, fields from the second
will be appended to the first, and the label and description will be kept
from the first one, as appropriate.

Note that fieldsets are specific to each schema, i.e. the fieldset in the
default schema above is unrelated to the one in the metadata schema.

    >>> model = load_string(schema)
    >>> getFieldNamesInOrder(model.schema)
    ['title', 'body', 'publication_date', 'author', 'expiry_date', 'notification_date']

    >>> getFieldNamesInOrder(model.schemata['metadata'])
    ['created', 'creator']
    
    >>> from plone.supermodel.model import FIELDSETS_KEY
    >>> model.schema.getTaggedValue(FIELDSETS_KEY)
    [<Fieldset 'dates' of publication_date, expiry_date, notification_date>]

    >>> model.schemata[u"metadata"].getTaggedValue(FIELDSETS_KEY)
    [<Fieldset 'standard' of creator>, <Fieldset 'dates' of created>, <Fieldset 'author' of >]

When we serialise a schema with fieldsets, fields will be grouped by
fieldset.

    >>> print serialize_model(model) # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema>
        <field name="title" type="zope.schema.TextLine">
          <title>Title</title>
        </field><field name="body" type="zope.schema.Text">
          <title>Body text</title>
          <max_length>10000</max_length>
        </field><field name="author" type="zope.schema.TextLine">
          <title>Author</title>
        </field><fieldset description="Standard dates" label="Dates" name="dates">
          <field name="publication_date" type="zope.schema.Date">
            <title>Publication date</title>
          </field><field name="expiry_date" type="zope.schema.Date">
            <title>Expiry date</title>
          </field><field name="notification_date" type="zope.schema.Date">
            <title>Notification date</title>
          </field>
        </fieldset>
      </schema><schema name="metadata">
        <fieldset label="Standard" name="standard">
          <field name="creator" type="zope.schema.TextLine">
            <description>Name of the creator</description>
            <title>Creator</title>
          </field>
        </fieldset><fieldset label="Metadata dates" name="dates">
          <field name="created" type="zope.schema.Datetime">
            <required>False</required>
            <title>Created date</title>
          </field>
        </fieldset><fieldset label="Author info" name="author" />
      </schema>
    </model>


Fieldsets can also be defined with directives:
    
    >>> import zope.schema
    >>> from plone.supermodel.directives import fieldset

    >>> class IGrouped(Schema):
    ...     
    ...     fieldset(u"default", label="Default", fields=['title', 'description'])
    ...     fieldset(u"metadata", label="Metadata", fields=['date'])
    ...     
    ...     title = zope.schema.TextLine(title=u"Title")
    ...     description = zope.schema.TextLine(title=u"Description")
    ...     
    ...     publication_date = zope.schema.Date(title=u"Publication date")

    >>> grok_component("IGrouped", IGrouped)
    True
    
    >>> from plone.supermodel.model import FIELDSETS_KEY
    >>> IGrouped.getTaggedValue(FIELDSETS_KEY)
    [<Fieldset 'default' of title, description>, <Fieldset 'metadata' of date>]

Creating custom metadata handlers
---------------------------------

The plone.supermodel format is extensible with custom utilities that can
write to a "metadata" dictionary. Such utilities may for example read
information captured in attributes in particular namespaces.

Let's imagine we wanted to make it possible to override form layout on a
per-schema level, and override widgets on a per-field level. For this, we
may expect to be able to parse a format like this:

    >>> schema = """\
    ... <?xml version="1.0" encoding="UTF-8"?>
    ... <model xmlns="http://namespaces.plone.org/supermodel/schema"
    ...        xmlns:ui="http://namespaces.acme.com/ui">
    ...     <schema ui:layout="horizontal">
    ...         <field type="zope.schema.TextLine" name="title"
    ...             ui:widget="largetype">
    ...             <title>Title</title>
    ...             <required>True</required>
    ...         </field>
    ...         <field type="zope.schema.Text" name="description">
    ...             <title>Description</title>
    ...             <description>A short summary</description>
    ...             <required>False</required>
    ...             <min_length>10</min_length>
    ...         </field>
    ...     </schema>
    ... </model>
    ... """

We can register schema and field metadata handlers as named utilities.
Metadata handlers should be able to reciprocally read and write metadata.

    >>> from zope.interface import implements
    >>> from zope.component import provideUtility

    >>> from plone.supermodel.interfaces import ISchemaMetadataHandler
    >>> from plone.supermodel.utils import ns

    >>> class FormLayoutMetadata(object):
    ...     implements(ISchemaMetadataHandler)
    ...     
    ...     namespace = "http://namespaces.acme.com/ui"
    ...     prefix = "ui"
    ...     
    ...     def read(self, schema_node, schema):
    ...         layout = schema_node.get(ns('layout', self.namespace))
    ...         if layout:
    ...             schema.setTaggedValue(u'acme.layout', layout)
    ...             
    ...     def write(self, schema_node, schema):
    ...         layout = schema.queryTaggedValue(u'acme.layout', None)
    ...         if layout:
    ...             schema_node.set(ns('layout', self.namespace), layout)

    >>> provideUtility(component=FormLayoutMetadata(), name='acme.ui.schema')

    >>> from plone.supermodel.interfaces import IFieldMetadataHandler
    >>> class FieldWidgetMetadata(object):
    ...     implements(IFieldMetadataHandler)
    ...     
    ...     namespace = "http://namespaces.acme.com/ui"
    ...     prefix = "ui"
    ...         
    ...     def read(self, field_node, schema, field):
    ...         name = field.__name__
    ...         widget = field_node.get(ns('widget', self.namespace))
    ...         if widget:
    ...             widgets = schema.queryTaggedValue(u'acme.widgets', {})
    ...             widgets[name] = widget
    ...             schema.setTaggedValue(u'acme.widgets', widgets)
    ...
    ...     def write(self, field_node, schema, field):
    ...         name = field.__name__
    ...         widget = schema.queryTaggedValue(u'acme.widgets', {}).get(name, {})
    ...         if widget:
    ...             field_node.set(ns('widget', self.namespace), widget)

    >>> provideUtility(component=FieldWidgetMetadata(), name='acme.ui.fields')

When this model is loaded, utilities above will be invoked for each schema
and each field, respectively.

    >>> model = load_string(schema)

    >>> model.schema.getTaggedValue('acme.layout')
    'horizontal'

    >>> model.schema.getTaggedValue('acme.widgets')
    {'title': 'largetype'}

Of course, we can also serialize the schema back to XML. Here, the 'prefix'
set in the utility (if any) will be used by default.

    >>> print serialize_model(model) # doctest: +NORMALIZE_WHITESPACE
    <model xmlns="http://namespaces.plone.org/supermodel/schema">
      <schema ui:layout="horizontal" xmlns:ui="http://namespaces.acme.com/ui">
        <field name="title" type="zope.schema.TextLine" ui:widget="largetype">
          <title>Title</title>
        </field><field name="description" type="zope.schema.Text">
          <min_length>10</min_length>
          <description>A short summary</description>
          <title>Description</title>
          <required>False</required>
        </field>
      </schema>
    </model>